# Chapter 0.2 - What Is Programming?

## Introduction

For this introduction I'm going to get a bit philosophical at times.  
I can understand if you want to skip this bit and move on to the 'fun' stuff,
but you'll get much more out of this tutorial if you take the time to read the text walls.  

## What Is Programming?

The answer to the question "what is programming?" is not a simple one.  

Many people will tell you that programming is about telling computers what to do.  
In a way that's true - a program is effectively just a set of instructions for a computer to follow.  
But in reality it's not quite that simple.  

The dictionary answer is that programming is:  
> The process of writing computer programs

That's closer, but it doesn't express quite how difficult that process can be.  
I don't think there's a single programmer on the planet who would say that programming is easy.  
(If you find one who does, they're either lying or they've got a really cushy job.)  

### Difficult

To an expert it can seem simple at times, but it takes a lot of skill and dedication to get to that point.
Right now if someone asked me
> Can you write a corecursive flood fill algorithm because the recursive one is causing a stack overflow?
I would say "Sure, sounds doable!", but four to five years ago I'd have just said "Do what now?".

Like any skill, programming is something that you have to develop.  
You start from scratch with no skill whatsoever, and gradually you learn, bit by bit.  
You chip away at it a piece at a time, until eventually you look back and realise just how far you've come.  

### Problem Solving

Many programmers agree that what programming is really about is problem solving.  

A programmer does not just tell a computer to do something, a programmer must explain to the computer exactly how it should do something.  

Programming always starts with a problem.  
A program always does something, and often the problem is how to do that something.  
For example, if you want to make a game then the overall problem is how to make the game.  

But then every program will in turn be made up of many smaller problems.

* How do I represent the world?  
* How do I get my character to move across the world?  
* How do I make the enemies behave intelligently?  

The program itself describes the solutions to these problems.  
When a program can represent the world, move the character, control the enemies et cetera, then that program becomes a collection of solutions.  

### Rewarding

When you dedicate yourself to it programming can be very rewarding.  

At first you can't do much.  
Everything's confusing.  
So many big words and acronyms and scary error messages.  

But every time you understand something, every time you get your program to do something new, every time you discover something new, each of these things is a small victory.  
Sometimes they're really exciting, sometimes they're only a small step towards a larger goal.  

And then when you look back several weeks down the line and look at how far you've come - that's the really rewarding thing.  
To go from being technically illiterate and impotent to realising just how much you've learned and just what you're now capable of - that is a miracle in itself.  
And then you stop and realise how much you still don't know, how far your journey has to go...  

In one way learning how to program spoils a bit of the magic.  
When you know how a game works, a little bit of the magic dies because you've seen the man behind the curtains.  
But at the same time you get a newfound respect for just how difficult it is to make a game.  
You look back at yourself saying "I want to make video games, how hard can it be?" and realise your naivity.  
But then you realise that you've done it anyway.  
Perhaps you haven't made the kind of games you truly wanted to, but you've made something you're proud of, and that feels great.  

## What Does It Mean To Be A Programmer?

Some people just see programming as a way to pay the bills.  
They usually work as a programmer on some boring business project for some big buisiness and then they go home and try to forget all about it.  
Personally I think that's kind of sad, like being an artist who only paints to pay the bills.  

Then there are the other people who program for fun.  
They don't care whether they work as a programmer or not, they still program when they get home and they make sure to program something that they enjoy.  
Personally I think they're the 'real' programmers, the ones who program for the sheer love of programming.  

To be a programmer means to be a problem solver - someone who sees a problem and feels compelled to try to solve it.  

Sometimes I think programming is the closest thing humans will ever get to magic or a super power.  
If humanity's defining quality is its ability to create tools, then the computer is the ultimate tool and programming is the ultimate expression of humanity's defining ability.  

Personally I think this is why so many programmers are geeks.  
Geeks love magic and super powers, so if programming is the closest thing we've got to magic then what self-respecting geek wouldn't want to give it a go?  
Not to mention the power of video games being the closest thing we have to a realisation of fantasy.  

## What Qualities Do You Need To Be A Programmer?

Before I list these, remember that too much of any of these traits can be a bad thing.

### Determination

Determination is by far the most important quality that a programmer can have.  

I've been in classes full of people trying to learn how to program and the ones who didn't do very well were almost always the ones who were quick to give up.  
The ones who excelled were the ones who refused to give up, the ones who refused to be scared off by the error messages or their lack of understanding.

Sometimes it might take you a long time to solve a problem, but if you keep trying then eventually you'll make progress.  
If you just give up on the problem because "it's too hard" then you'll never solve it.

Don't get me wrong, sometimes it's perfectly fine to realise that you're out of your depth and to ask for help (be it from a person or from the internet), but if you do that too much you end up becoming reliant on the help and never solve your own problems.

#### Advantage

A person who keeps trying is far more likely to succeed that someone who quits at the first hurdle.  
Likewise someone who refuses to let their lack of skill or knowledge get them down is going to do better than someone who gives in because they don't know what an error message means.  

#### Disadvantage

As I briefly mentioned before, the key disadvantage to determination is that sometimes you do have to admit defeat and ask for help.  
Even if another person can't solve your problem, getting another person's insight can sometimes lead you to realise something you were overlooking, which can in turn help you find the solution.  

Someone who is too determined and refuses to ask for help will do worse than someone who knows when to stop and ask for help or when to try a different approach.  

### Laziness

I know what you're thinking - "how can laziness be a good quality?"  

To quote Bill Gates:  
> I choose a lazy person to do a hard job.
> Because a lazy person will find an easy way to do it.

Of course the 'easy way' isn't always the best way, but being able to find a simple solution to a problem is usually a good thing.  
One of the many approaches to programming is the "keep it simple, stupid" (KISS) philosophy.  

But it's not just Bill Gates who agrees.

To quote Larry Wall, inventor of the infamous Perl programming language:  
> A lazy person will try to always find some way to do something; they'll always be looking for ways of doing something faster, more efficiently,

(If you don't believe me, here's [the source](https://www.youtube.com/watch?v=G49RUPv5-NU).)

#### Advantage

A lazy person will often try to reduce the amount of effort they have to exert to solve a problem.  
One of the significant manifestations of this is the creation of new tools designed to save time.  

For example, a lazy programmer will realise that writing a web crawler to scrape all the images out of a website is probably much less effort (and possibly more fun) than manually downloading the images.

#### Disadvantage

Unfortunately lazy people also tend to procrastinate, which is one of the ultimate enemies of all programmers, especially game developers.  

A procrastinating programmer will delay doing difficult things, and thus those difficult things may never get done.  

### Maths

Stop! Take your cursor off that back button! Hear me out first.  

Maths is _not_ essential to being able to program.  

However, there will be times where maths will be inescapable.  
Fortunately this doesn't mean having to do mental arithmetic under exam conditions.  
Most of the time all you need to do is decipher some mathematical formulas or concepts, turn them into something the computer can understand, and then forget about them.  

Personally, I believe that programming has made me a better mathematician than any of my former maths teachers ever could.  
It's ironic that none of them ever bothered to mention that maths is extremely useful for making video games.  
If they'd mentioned that, I'd probably have paid attention.  

#### Advantage

Understanding maths will naturally give you an upper hand when managing the problem solving aspect of programming.  
Being able to decipher those ridiculous mathematical forumulas will probably come in handy too.  

#### Disadvantage

Sometimes people who are good at maths are a bit too rigid and logical.  
Programming also requires creativity and imagination.  